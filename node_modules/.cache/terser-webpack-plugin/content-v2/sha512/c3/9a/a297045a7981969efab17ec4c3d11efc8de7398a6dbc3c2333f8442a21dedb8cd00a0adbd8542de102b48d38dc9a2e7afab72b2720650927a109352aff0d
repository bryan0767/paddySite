{"code":"webpackHotUpdate(\"vendors\",{\"./node_modules/dotenv/lib/main.js\":\n/*!*****************************************!*\\\n  !*** ./node_modules/dotenv/lib/main.js ***!\n  \\*****************************************/\n/*! no static exports found */function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(process) {/* @flow */\\n/*::\\n\\ntype DotenvParseOptions = {\\n  debug?: boolean\\n}\\n\\n// keys and values from src\\ntype DotenvParseOutput = { [string]: string }\\n\\ntype DotenvConfigOptions = {\\n  path?: string, // path to .env file\\n  encoding?: string, // encoding of .env file\\n  debug?: string // turn on logging for debugging purposes\\n}\\n\\ntype DotenvConfigOutput = {\\n  parsed?: DotenvParseOutput,\\n  error?: Error\\n}\\n\\n*/\\n\\nconst fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\\\"Cannot find module 'fs'\\\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\\nconst path = __webpack_require__(/*! path */ \\\"./node_modules/path-browserify/index.js\\\")\\n\\nfunction log (message /*: string */) {\\n  console.log(`[dotenv][DEBUG] ${message}`)\\n}\\n\\nconst NEWLINE = '\\\\n'\\nconst RE_INI_KEY_VAL = /^\\\\s*([\\\\w.-]+)\\\\s*=\\\\s*(.*)?\\\\s*$/\\nconst RE_NEWLINES = /\\\\\\\\n/g\\nconst NEWLINES_MATCH = /\\\\n|\\\\r|\\\\r\\\\n/\\n\\n// Parses src into an Object\\nfunction parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {\\n  const debug = Boolean(options && options.debug)\\n  const obj = {}\\n\\n  // convert Buffers before splitting into lines and processing\\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\\n    // matching \\\"KEY' and 'VAL' in 'KEY=VAL'\\n    const keyValueArr = line.match(RE_INI_KEY_VAL)\\n    // matched?\\n    if (keyValueArr != null) {\\n      const key = keyValueArr[1]\\n      // default undefined or missing values to empty string\\n      let val = (keyValueArr[2] || '')\\n      const end = val.length - 1\\n      const isDoubleQuoted = val[0] === '\\\"' && val[end] === '\\\"'\\n      const isSingleQuoted = val[0] === \\\"'\\\" && val[end] === \\\"'\\\"\\n\\n      // if single or double quoted, remove quotes\\n      if (isSingleQuoted || isDoubleQuoted) {\\n        val = val.substring(1, end)\\n\\n        // if double quoted, expand newlines\\n        if (isDoubleQuoted) {\\n          val = val.replace(RE_NEWLINES, NEWLINE)\\n        }\\n      } else {\\n        // remove surrounding whitespace\\n        val = val.trim()\\n      }\\n\\n      obj[key] = val\\n    } else if (debug) {\\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)\\n    }\\n  })\\n\\n  return obj\\n}\\n\\n// Populates process.env from .env file\\nfunction config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {\\n  let dotenvPath = path.resolve(process.cwd(), '.env')\\n  let encoding /*: string */ = 'utf8'\\n  let debug = false\\n\\n  if (options) {\\n    if (options.path != null) {\\n      dotenvPath = options.path\\n    }\\n    if (options.encoding != null) {\\n      encoding = options.encoding\\n    }\\n    if (options.debug != null) {\\n      debug = true\\n    }\\n  }\\n\\n  try {\\n    // specifying an encoding returns a string instead of a buffer\\n    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })\\n\\n    Object.keys(parsed).forEach(function (key) {\\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\\n        process.env[key] = parsed[key]\\n      } else if (debug) {\\n        log(`\\\"${key}\\\" is already defined in \\\\`process.env\\\\` and will not be overwritten`)\\n      }\\n    })\\n\\n    return { parsed }\\n  } catch (e) {\\n    return { error: e }\\n  }\\n}\\n\\nmodule.exports.config = config\\nmodule.exports.parse = parse\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \\\"./node_modules/process/browser.js\\\")))\\n\\n//# sourceURL=webpack:///./node_modules/dotenv/lib/main.js?\")},\"./node_modules/path-browserify/index.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/path-browserify/index.js ***!\n  \\***********************************************/\n/*! no static exports found */function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// resolves . and .. elements in a path array with directory names there\\n// must be no slashes, empty elements, or device names (c:\\\\) in the array\\n// (so also no leading and trailing slashes - it does not distinguish\\n// relative and absolute paths)\\nfunction normalizeArray(parts, allowAboveRoot) {\\n  // if the path tries to go above the root, `up` ends up > 0\\n  var up = 0;\\n  for (var i = parts.length - 1; i >= 0; i--) {\\n    var last = parts[i];\\n    if (last === '.') {\\n      parts.splice(i, 1);\\n    } else if (last === '..') {\\n      parts.splice(i, 1);\\n      up++;\\n    } else if (up) {\\n      parts.splice(i, 1);\\n      up--;\\n    }\\n  }\\n\\n  // if the path is allowed to go above the root, restore leading ..s\\n  if (allowAboveRoot) {\\n    for (; up--; up) {\\n      parts.unshift('..');\\n    }\\n  }\\n\\n  return parts;\\n}\\n\\n// Split a filename into [root, dir, basename, ext], unix version\\n// 'root' is just a slash, or nothing.\\nvar splitPathRe =\\n    /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;\\nvar splitPath = function(filename) {\\n  return splitPathRe.exec(filename).slice(1);\\n};\\n\\n// path.resolve([from ...], to)\\n// posix version\\nexports.resolve = function() {\\n  var resolvedPath = '',\\n      resolvedAbsolute = false;\\n\\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\\n    var path = (i >= 0) ? arguments[i] : process.cwd();\\n\\n    // Skip empty and invalid entries\\n    if (typeof path !== 'string') {\\n      throw new TypeError('Arguments to path.resolve must be strings');\\n    } else if (!path) {\\n      continue;\\n    }\\n\\n    resolvedPath = path + '/' + resolvedPath;\\n    resolvedAbsolute = path.charAt(0) === '/';\\n  }\\n\\n  // At this point the path should be resolved to a full absolute path, but\\n  // handle relative paths to be safe (might happen when process.cwd() fails)\\n\\n  // Normalize the path\\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\\n    return !!p;\\n  }), !resolvedAbsolute).join('/');\\n\\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\\n};\\n\\n// path.normalize(path)\\n// posix version\\nexports.normalize = function(path) {\\n  var isAbsolute = exports.isAbsolute(path),\\n      trailingSlash = substr(path, -1) === '/';\\n\\n  // Normalize the path\\n  path = normalizeArray(filter(path.split('/'), function(p) {\\n    return !!p;\\n  }), !isAbsolute).join('/');\\n\\n  if (!path && !isAbsolute) {\\n    path = '.';\\n  }\\n  if (path && trailingSlash) {\\n    path += '/';\\n  }\\n\\n  return (isAbsolute ? '/' : '') + path;\\n};\\n\\n// posix version\\nexports.isAbsolute = function(path) {\\n  return path.charAt(0) === '/';\\n};\\n\\n// posix version\\nexports.join = function() {\\n  var paths = Array.prototype.slice.call(arguments, 0);\\n  return exports.normalize(filter(paths, function(p, index) {\\n    if (typeof p !== 'string') {\\n      throw new TypeError('Arguments to path.join must be strings');\\n    }\\n    return p;\\n  }).join('/'));\\n};\\n\\n\\n// path.relative(from, to)\\n// posix version\\nexports.relative = function(from, to) {\\n  from = exports.resolve(from).substr(1);\\n  to = exports.resolve(to).substr(1);\\n\\n  function trim(arr) {\\n    var start = 0;\\n    for (; start < arr.length; start++) {\\n      if (arr[start] !== '') break;\\n    }\\n\\n    var end = arr.length - 1;\\n    for (; end >= 0; end--) {\\n      if (arr[end] !== '') break;\\n    }\\n\\n    if (start > end) return [];\\n    return arr.slice(start, end - start + 1);\\n  }\\n\\n  var fromParts = trim(from.split('/'));\\n  var toParts = trim(to.split('/'));\\n\\n  var length = Math.min(fromParts.length, toParts.length);\\n  var samePartsLength = length;\\n  for (var i = 0; i < length; i++) {\\n    if (fromParts[i] !== toParts[i]) {\\n      samePartsLength = i;\\n      break;\\n    }\\n  }\\n\\n  var outputParts = [];\\n  for (var i = samePartsLength; i < fromParts.length; i++) {\\n    outputParts.push('..');\\n  }\\n\\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n\\n  return outputParts.join('/');\\n};\\n\\nexports.sep = '/';\\nexports.delimiter = ':';\\n\\nexports.dirname = function(path) {\\n  var result = splitPath(path),\\n      root = result[0],\\n      dir = result[1];\\n\\n  if (!root && !dir) {\\n    // No dirname whatsoever\\n    return '.';\\n  }\\n\\n  if (dir) {\\n    // It has a dirname, strip trailing slash\\n    dir = dir.substr(0, dir.length - 1);\\n  }\\n\\n  return root + dir;\\n};\\n\\n\\nexports.basename = function(path, ext) {\\n  var f = splitPath(path)[2];\\n  // TODO: make this comparison case-insensitive on windows?\\n  if (ext && f.substr(-1 * ext.length) === ext) {\\n    f = f.substr(0, f.length - ext.length);\\n  }\\n  return f;\\n};\\n\\n\\nexports.extname = function(path) {\\n  return splitPath(path)[3];\\n};\\n\\nfunction filter (xs, f) {\\n    if (xs.filter) return xs.filter(f);\\n    var res = [];\\n    for (var i = 0; i < xs.length; i++) {\\n        if (f(xs[i], i, xs)) res.push(xs[i]);\\n    }\\n    return res;\\n}\\n\\n// String.prototype.substr - negative index don't work in IE8\\nvar substr = 'ab'.substr(-1) === 'b'\\n    ? function (str, start, len) { return str.substr(start, len) }\\n    : function (str, start, len) {\\n        if (start < 0) start = str.length + start;\\n        return str.substr(start, len);\\n    }\\n;\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \\\"./node_modules/process/browser.js\\\")))\\n\\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?\")}});","extractedComments":[]}